<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Calling Rust from C# | Ramblings of a Software Engineer</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Calling Rust from C#" />
<meta name="author" content="Don Grote" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="There’s been a general call to arms at work for folks to begin shifting to the Rust programming language. Pair that with my overall distaste for C#, and you find yourself with a motivated software engineer eager to begin transitioning their project to Rust. Our approach for making the transition involves utilizing the foreign function interface capabilities of Rust and C#. I decided to document my entire process here, so that others may follow along and so that I may reference it should I ever find the need." />
<meta property="og:description" content="There’s been a general call to arms at work for folks to begin shifting to the Rust programming language. Pair that with my overall distaste for C#, and you find yourself with a motivated software engineer eager to begin transitioning their project to Rust. Our approach for making the transition involves utilizing the foreign function interface capabilities of Rust and C#. I decided to document my entire process here, so that others may follow along and so that I may reference it should I ever find the need." />
<link rel="canonical" href="https://dongrote.github.io/2024/08/18/calling-rust-from-c.html" />
<meta property="og:url" content="https://dongrote.github.io/2024/08/18/calling-rust-from-c.html" />
<meta property="og:site_name" content="Ramblings of a Software Engineer" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-08-18T07:09:51-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Calling Rust from C#" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Don Grote"},"dateModified":"2024-08-18T07:09:51-05:00","datePublished":"2024-08-18T07:09:51-05:00","description":"There’s been a general call to arms at work for folks to begin shifting to the Rust programming language. Pair that with my overall distaste for C#, and you find yourself with a motivated software engineer eager to begin transitioning their project to Rust. Our approach for making the transition involves utilizing the foreign function interface capabilities of Rust and C#. I decided to document my entire process here, so that others may follow along and so that I may reference it should I ever find the need.","headline":"Calling Rust from C#","mainEntityOfPage":{"@type":"WebPage","@id":"https://dongrote.github.io/2024/08/18/calling-rust-from-c.html"},"url":"https://dongrote.github.io/2024/08/18/calling-rust-from-c.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://dongrote.github.io/feed.xml" title="Ramblings of a Software Engineer" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Ramblings of a Software Engineer</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About the Author</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Calling Rust from C#</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-08-18T07:09:51-05:00" itemprop="datePublished">Aug 18, 2024
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Don Grote</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>There’s been a general call to arms at work for folks to begin
shifting to the <a href="https://www.rust-lang.org">Rust</a> programming language.
Pair that with my overall distaste for C#, and you find yourself with
a motivated software engineer eager to begin transitioning their
project to Rust. Our approach for making the transition involves utilizing
the foreign function interface capabilities of Rust and C#.
I decided to document my entire process here, so that others may follow
along and so that I may reference it should I ever find the need.</p>

<p>We will begin with a pairing of very simple C# and Rust programs to establish
the connection between the two via the <abbr title="Foreign Function Interface">FFI</abbr>.
Once we’ve got that working we’ll make sure the solution is cross-platform, so as
not to impede the workflow of any of our colleagues who likely prefer to work in
Visual Studio rather than NeoVim.</p>

<p>Finally, we’ll setup the <abbr title="Foreign Function Interface">FFI</abbr> function
on the C# side to make it look like a typical C# method.</p>

<ol>
  <li>Install dependencies</li>
  <li>Setup the project directory structure</li>
  <li>Write the code to make C# call the function implemented in a Rust library</li>
  <li>Modify the Rust library to export a function for C# to call.</li>
  <li>Configure MSBuild to build and relocate our Rust library</li>
</ol>

<h1 id="install-dependencies">Install Dependencies</h1>

<p>We’re going to have to install both the .NET SDK and Rust. If you already have
these installed, skip to the <a href="#setup-project-directory">Setup Project Directory</a> section.</p>

<h2 id="install-net-sdk">Install .NET SDK</h2>

<p>Microsoft provides <a href="https://learn.microsoft.com/en-us/dotnet/core/install/linux">comprehensive instructions</a> for
installing the .NET SDK on their <a href="https://learn.microsoft.com">Learn site</a>.</p>

<h2 id="install-rust">Install Rust</h2>

<p>As of this writing, the Rust installation instructions can be found
<a href="https://www.rust-lang.org/tools/install">on their website</a>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~<span class="nv">$ </span>curl <span class="nt">--proto</span> <span class="s1">'=https'</span> <span class="nt">--tlsv1</span>.2 <span class="nt">-sSf</span> https://sh.rustup.rs | sh
</code></pre></div></div>

<blockquote>
  <p><strong>Note:</strong> Be sure to read directions after the installation succeeds
regarding updating your shell environment to be aware of the newly
installed Rust toolchain.</p>
</blockquote>

<h1 id="setup-project-directory">Setup Project Directory</h1>

<p>Let’s establish the root of our project some place easy: <code class="language-plaintext highlighter-rouge">~/rs-in-cs</code>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~<span class="nv">$ </span><span class="nb">mkdir</span> ~/rs-in-cs <span class="o">&amp;&amp;</span> <span class="nb">cd</span> ~/rs-in-cs
</code></pre></div></div>

<h2 id="create-the-net-solution--project">Create the .NET Solution / Project</h2>
<p>Next, let’s create our .NET solution and project files.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/rs-in-cs<span class="nv">$ </span>dotnet new create sln
</code></pre></div></div>
<p>This will create a solution file named <code class="language-plaintext highlighter-rouge">rs-in-cs.sln</code> in the root of our project directory.
Next, let’s create our C# project directory and file.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/rs-in-cs<span class="nv">$ </span><span class="nb">mkdir </span>app <span class="o">&amp;&amp;</span> <span class="nb">cd </span>app
~/rs-in-cs/app<span class="nv">$ </span>dotnet new create console <span class="nt">--use-program-main</span>
~/rs-in-cs/app<span class="nv">$ </span><span class="nb">cd</span> -
</code></pre></div></div>

<p>Now an <code class="language-plaintext highlighter-rouge">app.csproj</code> and <code class="language-plaintext highlighter-rouge">Program.cs</code> files have been created. Let’s add a reference to our
project file into our solution file.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/rs-in-cs<span class="nv">$ </span>dotnet sln add app/app.csproj
</code></pre></div></div>

<p>Before moving onto create our Rust library, let’s make sure we can build and run our C# program.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/rs-in-cs<span class="nv">$ </span>dotnet run <span class="nt">--project</span> app/app.csproj
</code></pre></div></div>

<h2 id="create-the-rust-library">Create the Rust Library</h2>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/rs-in-cs<span class="nv">$ </span>cargo new rustfn <span class="nt">--lib</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Note:</strong> Beware of the <code class="language-plaintext highlighter-rouge">cargo new</code> command creating a <code class="language-plaintext highlighter-rouge">.git</code> directory and <code class="language-plaintext highlighter-rouge">.gitignore</code> file on your behalf.
If you try to create a git repository out of this project later, you’ll get an error when trying to add this
folder to your repository. Delete the <code class="language-plaintext highlighter-rouge">.git</code> directory to be able to add the <code class="language-plaintext highlighter-rouge">rustfn</code> directory to your
repository, otherwise you can ignore it.</p>
</blockquote>

<p>Likewise with the C# program, let’s make sure our Rust library builds and the provided tests run.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/rs-in-cs<span class="nv">$ </span><span class="nb">cd </span>rustfn
~/rs-in-cs/rustfn<span class="nv">$ </span>cargo <span class="nb">test</span>
~/rs-in-cs/rustfn<span class="nv">$ </span><span class="nb">cd</span> -
</code></pre></div></div>
<h1 id="establish-the-foreign-function-interface-link">Establish the Foreign Function Interface Link</h1>

<p>To get C# to call a Rust function, we’re going to have to keep switching back and forth between the two
languages, setting them up to be able to interact with each other.</p>

<h2 id="modify-the-c-program">Modify the C# Program</h2>

<p>The default <code class="language-plaintext highlighter-rouge">Program.cs</code> file generated by the <code class="language-plaintext highlighter-rouge">dotnet</code> command should look like the following:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">app</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Hello, World!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’re going to move the <code class="language-plaintext highlighter-rouge">Console.WriteLine</code> call into it’s own <code class="language-plaintext highlighter-rouge">static</code> method as we prepare to replace
it with a function implemented in our <code class="language-plaintext highlighter-rouge">rustfn</code> library.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">app</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="nf">PrintHelloWorld</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">PrintHelloWorld</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"C#: Hello, World!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’ve added a <code class="language-plaintext highlighter-rouge">C#: </code> prefix to the Hello, World message so that we can see from what language our
message is being printed.</p>

<p>We can run it again to verify:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/rs-in-cs<span class="nv">$ </span>dotnet run <span class="nt">--project</span> app/app.csproj
C#: Hello, World!
</code></pre></div></div>

<h2 id="modify-the-rust-library">Modify the Rust Library</h2>
<p>Now let’s shift gears over to our Rust library. We’re going to strip this down and make it as simple as we can.
No parameters, no return value. Only a single <code class="language-plaintext highlighter-rouge">println!()</code>.</p>

<p>Open the <code class="language-plaintext highlighter-rouge">rustfn/src/lib.rs</code> file and replace its contents with the following:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">print_hello_world</span><span class="p">()</span> <span class="p">{</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"RS: Hello, World!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can run <code class="language-plaintext highlighter-rouge">cargo build</code> to verify that we didn’t break anything.</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/rs-in-cs/rustfn<span class="nv">$ </span>cargo build
</code></pre></div></div>

<h3 id="export-the-rust-function">Export the Rust Function</h3>
<p>We have our simple Rust function, but as it is written, it isn’t ready for import by another language.
We need to decorate the rust function declaration a bit. First we apply the <code class="language-plaintext highlighter-rouge">#[no_mangle]</code> to prevent
the Rust toolchain from mangling the function symbol. We also need to mark the function symbol for export
via the <code class="language-plaintext highlighter-rouge">extern "C"</code> keyword.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">print_hello_world</span><span class="p">()</span> <span class="p">{</span>
  <span class="nd">println!</span><span class="p">(</span><span class="s">"RS: Hello, World!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we run <code class="language-plaintext highlighter-rouge">cargo build</code> at this point and check our <code class="language-plaintext highlighter-rouge">target/debug</code> directory, we will find a <code class="language-plaintext highlighter-rouge">librustfn.rlib</code> file
instead of a <code class="language-plaintext highlighter-rouge">librustfn.so</code> shared object file that we need for dynamic linking in our C# program.
We need to configure Rust via <code class="language-plaintext highlighter-rouge">rustfn/Cargo.toml</code> to generate the <code class="language-plaintext highlighter-rouge">.so</code> file.</p>

<p>We’re going to add <code class="language-plaintext highlighter-rouge">libc = "*"</code> under <code class="language-plaintext highlighter-rouge">[dependencies]</code>, and at the end of the file, we’ll add</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[lib]</span>
<span class="py">crate-type</span> <span class="p">=</span> <span class="nn">["cdylib"]</span>
</code></pre></div></div>

<p>Our final <code class="language-plaintext highlighter-rouge">rustfn/Cargo.toml</code> file should look like this:</p>
<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"rustfn"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>
<span class="py">libc</span> <span class="p">=</span> <span class="s">"*"</span>

<span class="nn">[lib]</span>
<span class="py">crate-type</span> <span class="p">=</span> <span class="nn">["cdylib"]</span>
</code></pre></div></div>

<p>Now, when we run <code class="language-plaintext highlighter-rouge">cargo build</code> it will produce a <code class="language-plaintext highlighter-rouge">target/debug/librustfn.so</code> shared ELF file for us.</p>

<h2 id="import-the-rust-function-into-c">Import the Rust Function into C#</h2>

<p>Next, we switch back to our C# program to setup the <abbr title="Foreign Function Interface">FFI</abbr>
import. This is where the magic happens. We’re going to use the <code class="language-plaintext highlighter-rouge">DllImportAttribute</code> to decorate a <code class="language-plaintext highlighter-rouge">static</code>
method declaration. Notice that we make sure the <abbr title="Foreign Function Interface">FFI</abbr> declaration
matches the exported function signature from our Rust library.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"rustfn"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">extern</span> <span class="k">void</span> <span class="nf">print_hello_world</span><span class="p">();</span>
</code></pre></div></div>

<p>we’re going to replace the implementation of our <code class="language-plaintext highlighter-rouge">PrintHelloWorld</code> method with a call to this declaration.</p>

<blockquote>
  <p><strong>Note:</strong> We have to import the <code class="language-plaintext highlighter-rouge">System.Runtime.InteropServices</code> namespace for the <code class="language-plaintext highlighter-rouge">DllImportAttribute</code>.</p>
</blockquote>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">app</span><span class="p">;</span>

<span class="k">using</span> <span class="nn">System.Runtime.InteropServices</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"rustfn"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">extern</span> <span class="k">void</span> <span class="nf">print_hello_world</span><span class="p">();</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nf">PrintHelloWorld</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">PrintHelloWorld</span><span class="p">()</span>
    <span class="p">{</span>
      <span class="nf">print_hello_world</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As this is written, we can build it, but we won’t be able to run it. At least, not successfully.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/rs-in-cs<span class="nv">$ </span>dotnet run <span class="nt">--project</span> app/app.csproj
Unhandled exception. System.DllNotFoundException: Unable to load shared library <span class="s1">'rustfn'</span> or one of its dependencies.
</code></pre></div></div>

<p>It’ll throw a <code class="language-plaintext highlighter-rouge">DllNotFoundException</code> when it tries and fails to find <code class="language-plaintext highlighter-rouge">librustfn.so</code>.
One of the places it’ll look for the library is in the same directory as our built console application.
What we can do, for now, is copy the <code class="language-plaintext highlighter-rouge">librustfn.so</code> file built by <code class="language-plaintext highlighter-rouge">cargo</code> into the <code class="language-plaintext highlighter-rouge">app/bin/Debug/net8.0</code> directory
and run our console app.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/rs-in-cs<span class="nv">$ </span><span class="nb">cp </span>rustfn/target/debug/librustfn.so app/bin/Debug/net8.0
~/rs-in-cs<span class="nv">$ </span>dotnet run <span class="nt">--project</span> app/app.csproj
RS: Hello, World!
</code></pre></div></div>

<p>Now, instead of seeing the <code class="language-plaintext highlighter-rouge">C#: </code> prefix in front of our <code class="language-plaintext highlighter-rouge">Hello, World!</code>, we should see <code class="language-plaintext highlighter-rouge">RS: </code>, indicating that
our <code class="language-plaintext highlighter-rouge">Hello, World!</code> is now coming from Rust instead of C#.</p>

<p>Congratulation! You got a C# program to call a function built in Rust!</p>

<h2 id="configure-msbuild">Configure MSBuild</h2>

<p>We got C# to call Rust, but building a shared object file with <code class="language-plaintext highlighter-rouge">cargo build</code> and then copying it into
the potentially changing folder of the console application binary isn’t sustainable. It’s time to configure
our tooling to handle this step for us making it nearly transparent.</p>

<h3 id="configure-debug-build">Configure Debug Build</h3>

<p>We’re going to add this
<a href="https://learn.microsoft.com/en-us/visualstudio/msbuild/target-element-msbuild"><code class="language-plaintext highlighter-rouge">&lt;Target&gt;</code> element</a> inside of
the <a href="https://learn.microsoft.com/en-us/visualstudio/msbuild/project-element-msbuild"><code class="language-plaintext highlighter-rouge">&lt;Project&gt;</code> element</a> in
our <code class="language-plaintext highlighter-rouge">app/app.csproj</code> file:</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Target</span> <span class="na">Name=</span><span class="s">"Rust Build"</span> <span class="na">BeforeTargets=</span><span class="s">"Compile"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Exec</span>
        <span class="na">Condition=</span><span class="s">"'$(Configuration)' == 'Debug'"</span>
        <span class="na">Command=</span><span class="s">"cargo build"</span>
        <span class="na">WorkingDirectory=</span><span class="s">"./../rustfn"</span>
    <span class="nt">/&gt;</span>
<span class="nt">&lt;/Target&gt;</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;Target Name="Rust Build" BeforeTargets="Compile"&gt;</code></p>

<p>We’re creating a new <a href="https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets">build target</a>.
We’re naming it <code class="language-plaintext highlighter-rouge">Rust Build</code> and scheduling it to run before the built-in <code class="language-plaintext highlighter-rouge">Compile</code> target.</p>

<p><code class="language-plaintext highlighter-rouge">&lt;Exec</code></p>

<p>We’re setting up the shell command that MSBuild is going to execute to build our Rust library.</p>

<p><code class="language-plaintext highlighter-rouge">Condition="'$(Configuration)' == 'Debug'"</code></p>

<p>We’re configuring MSBuild to <em>conditionally</em> execute the command we’re setting up. Only when the built-in
MSBuild variable <code class="language-plaintext highlighter-rouge">Configuration</code> is set to the value <code class="language-plaintext highlighter-rouge">'Debug'</code> will we run the following command.</p>

<p><code class="language-plaintext highlighter-rouge">Command="cargo build"</code></p>

<p>This is the shell command that MSBuild is going to run. This is the same command we’ve been using ourselves
to get Rust to build the debug version of our library.</p>

<p><code class="language-plaintext highlighter-rouge">WorkingDirectory="./../rustfn"</code></p>

<p>This is the directory from which MSBuild will run <code class="language-plaintext highlighter-rouge">cargo build</code>. The path is relative to our <code class="language-plaintext highlighter-rouge">app.csproj</code> file.
We need to get MSBuild to run <code class="language-plaintext highlighter-rouge">cargo build</code> from the Rust library’s root directory.</p>

<h3 id="configure-release-build">Configure Release Build</h3>

<p>Within the previously created <code class="language-plaintext highlighter-rouge">&lt;Target&gt;</code> element, we create another
<a href="https://learn.microsoft.com/en-us/visualstudio/msbuild/exec-task"><code class="language-plaintext highlighter-rouge">&lt;Exec&gt;</code> element</a>, only changing the
<code class="language-plaintext highlighter-rouge">Condition</code> and the <code class="language-plaintext highlighter-rouge">Command</code> attributes:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Exec</span>
    <span class="na">Condition=</span><span class="s">"'$(Configuration)' == 'Release'"</span>
    <span class="na">Command=</span><span class="s">"cargo build --release"</span>
    <span class="na">WorkingDirectory=</span><span class="s">"./../rustfn"</span>
<span class="nt">/&gt;</span>
</code></pre></div></div>

<p>We change the <code class="language-plaintext highlighter-rouge">Condition</code> to only match when the build <code class="language-plaintext highlighter-rouge">Configuration</code> is <code class="language-plaintext highlighter-rouge">'Release'</code>. And we add <code class="language-plaintext highlighter-rouge">--release</code> to our
<code class="language-plaintext highlighter-rouge">cargo build</code> command so that it builds the release version of our Rust library.</p>

<p>Our final <code class="language-plaintext highlighter-rouge">&lt;Target&gt;</code> element looks like this:</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Target</span> <span class="na">Name=</span><span class="s">"Rust Build"</span> <span class="na">BeforeTargets=</span><span class="s">"Compile"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;Exec</span>
    <span class="na">Condition=</span><span class="s">"'$(Configuration)' == 'Debug'"</span>
    <span class="na">Command=</span><span class="s">"cargo build"</span>
    <span class="na">WorkingDirectory=</span><span class="s">"./../rustfn"</span>
  <span class="nt">/&gt;</span>
  <span class="nt">&lt;Exec</span>
    <span class="na">Condition=</span><span class="s">"'$(Configuration)' == 'Release'"</span>
    <span class="na">Command=</span><span class="s">"cargo build --release"</span>
    <span class="na">WorkingDirectory=</span><span class="s">"./../rustfn"</span>
  <span class="nt">/&gt;</span>
<span class="nt">&lt;/Target&gt;</span>
</code></pre></div></div>

<h3 id="copy-shared-object-file-linux">Copy Shared Object File (Linux)</h3>

<p>We’re going to add an 
<a href="https://learn.microsoft.com/en-us/visualstudio/msbuild/itemgroup-element-msbuild"><code class="language-plaintext highlighter-rouge">&lt;ItemGroup&gt;</code> element</a>
into our <code class="language-plaintext highlighter-rouge">&lt;Project&gt;</code> element. This <code class="language-plaintext highlighter-rouge">&lt;ItemGroup&gt;</code> is going to detail files that we need to copy from one
place to another.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;ItemGroup&gt;</span>
  <span class="nt">&lt;Content</span>
    <span class="na">Condition=</span><span class="s">"Exists('./../rustfn/target/$(Configuration.ToLower())/librustfn.so')"</span>
    <span class="na">Include=</span><span class="s">"./../rustfn/target/$(Configuration.ToLower())/librustfn.so"</span>
  <span class="nt">&gt;</span>
    <span class="nt">&lt;CopyToOutputDirectory&gt;</span>PreserveNewest<span class="nt">&lt;/CopyToOutputDirectory&gt;</span>
  <span class="nt">&lt;/Content&gt;</span>
<span class="nt">&lt;/ItemGroup&gt;</span>
</code></pre></div></div>

<p>The <a href="https://learn.microsoft.com/en-us/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#content"><code class="language-plaintext highlighter-rouge">&lt;Content&gt;</code> element</a>
represents files that are to be embedded within our C# project.</p>

<p><code class="language-plaintext highlighter-rouge">Condition="Exists('./../rustfn/target/$(Configuration.ToLower())/librustfn.so')"</code></p>

<p>Only when this <code class="language-plaintext highlighter-rouge">Condition</code> evaluates to <code class="language-plaintext highlighter-rouge">true</code> do we <code class="language-plaintext highlighter-rouge">Include</code> (copy) our <code class="language-plaintext highlighter-rouge">librustfn.so</code> file.
The <code class="language-plaintext highlighter-rouge">Condition</code> is that a particular file <code class="language-plaintext highlighter-rouge">Exists</code>; if the file doesn’t exist then we ignore this element.
An issue that comes up is that MSBuild uses <code class="language-plaintext highlighter-rouge">Release</code> and <code class="language-plaintext highlighter-rouge">Debug</code> for their <code class="language-plaintext highlighter-rouge">Configuration</code> values, but Rust
uses <code class="language-plaintext highlighter-rouge">release</code> and <code class="language-plaintext highlighter-rouge">debug</code> for their directory names during the build process. To be able to utilize the
MSBuild <code class="language-plaintext highlighter-rouge">Configuration</code> value in these rules, we use the <code class="language-plaintext highlighter-rouge">.ToLower()</code> method to convert <code class="language-plaintext highlighter-rouge">'Release'</code> into <code class="language-plaintext highlighter-rouge">'release'</code>,
and likewise with <code class="language-plaintext highlighter-rouge">'Debug'</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">&lt;CopyToOutputDirectory&gt;</code> value determines when to copy the <code class="language-plaintext highlighter-rouge">Include</code> file to the project output directory.
Permitted values are <code class="language-plaintext highlighter-rouge">Never</code>, <code class="language-plaintext highlighter-rouge">Always</code>, and <code class="language-plaintext highlighter-rouge">PreserveNewest</code>.</p>

<h3 id="copy-dynamic-link-library-windows">Copy Dynamic Link Library (Windows)</h3>

<p>The previous <code class="language-plaintext highlighter-rouge">&lt;Content&gt;</code> element we just added works when running on Linux. But if we want this to also work in
Visual Studio on Windows, we need to recognize that <code class="language-plaintext highlighter-rouge">cargo build</code> will generate <code class="language-plaintext highlighter-rouge">rustfn.dll</code> instead of <code class="language-plaintext highlighter-rouge">librustfn.so</code>.
So we add another rule to copy the <code class="language-plaintext highlighter-rouge">rustfn.dll</code> file when it exists. Within the same <code class="language-plaintext highlighter-rouge">&lt;ItemGroup&gt;</code> element, add another
<code class="language-plaintext highlighter-rouge">&lt;Content&gt;</code> element:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Content</span>
    <span class="na">Condition=</span><span class="s">"Exists('./../rustfn/target/$(Configuration.ToLower())/rustfn.dll')"</span>
    <span class="na">Include=</span><span class="s">"./../rustfn/target/$(Configuration.ToLower())/rustfn.dll"</span>
<span class="nt">&gt;</span>
  <span class="nt">&lt;CopyToOutputDirectory&gt;</span>PreserveNewest<span class="nt">&lt;/CopyToOutputDirectory&gt;</span>
<span class="nt">&lt;/Content&gt;</span>
</code></pre></div></div>

<h3 id="test-our-build">Test Our Build</h3>

<p>Now we should be able to delete all of our previously built binaries, run a single <code class="language-plaintext highlighter-rouge">dotnet build</code> and then
<code class="language-plaintext highlighter-rouge">dotnet run --project app/app.csproj</code> should “just work.”</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/rs-in-cs<span class="nv">$ </span><span class="nb">rm</span> <span class="nt">-rf</span> app/bin rustfn/target
~/rs-in-cs<span class="nv">$ </span>dotnet build
  Determining projects to restore...
  All projects are up-to-date <span class="k">for </span>restore.
  Configuration: Debug
     Compiling libc v0.2.157
     Compiling rustfn v0.1.0 <span class="o">(</span>~/rs-in-cs/rustfn<span class="o">)</span>
      Finished <span class="sb">`</span>dev<span class="sb">`</span> profile <span class="o">[</span>unoptimized + debuginfo] target<span class="o">(</span>s<span class="o">)</span> <span class="k">in </span>0.41s
  app -&gt; ~/rs-in-cs/app/bin/Debug/net8.0/app.dll

Build succeeded.
    0 Warning<span class="o">(</span>s<span class="o">)</span>
    0 Error<span class="o">(</span>s<span class="o">)</span>

Time Elapsed 00:00:00.86
~/rs-in-cs<span class="nv">$ </span>dotnet run <span class="nt">--project</span> app/app.csproj
RS: Hello, World!
</code></pre></div></div>

<h2 id="make-it-pretty">Make it Pretty</h2>

<p>Finally, let’s make our <abbr title="Foreign Function Interface">FFI</abbr> declaration look more like a C#
method (<code class="language-plaintext highlighter-rouge">CamelCase</code>) and less like a Rust function (<code class="language-plaintext highlighter-rouge">snake_case</code>).</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"rustfn"</span><span class="p">,</span> <span class="n">EntryPoint</span> <span class="p">=</span> <span class="s">"print_hello_world"</span><span class="p">)]</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">extern</span> <span class="k">void</span> <span class="nf">PrintHelloWorld</span><span class="p">();</span>
</code></pre></div></div>

<p>With <code class="language-plaintext highlighter-rouge">EntryPoint</code> we specify the exported Rust library symbol, enabling us to name the declaration whatever we want.
Now, our <code class="language-plaintext highlighter-rouge">Program.cs</code> file should look like this:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">app</span><span class="p">;</span>

<span class="k">using</span> <span class="nn">System.Runtime.InteropServices</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"rustfn"</span><span class="p">,</span> <span class="n">EntryPoint</span> <span class="p">=</span> <span class="s">"print_hello_world"</span><span class="p">)]</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">extern</span> <span class="k">void</span> <span class="nf">PrintHelloWorld</span><span class="p">();</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nf">PrintHelloWorld</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Make sure it works:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/rs-in-cs<span class="nv">$ </span>dotnet build <span class="o">&amp;&amp;</span> dotnet run <span class="nt">--project</span> app/app.csproj
  Determining projects to restore...
  All projects are up-to-date <span class="k">for </span>restore.
  Configuration: Debug
      Finished <span class="sb">`</span>dev<span class="sb">`</span> profile <span class="o">[</span>unoptimized + debuginfo] target<span class="o">(</span>s<span class="o">)</span> <span class="k">in </span>0.00s
  app -&gt; ~/rs-in-cs/app/bin/Debug/net8.0/app.dll

Build succeeded.
    0 Warning<span class="o">(</span>s<span class="o">)</span>
    0 Error<span class="o">(</span>s<span class="o">)</span>

Time Elapsed 00:00:01.24
RS: Hello, World!
</code></pre></div></div>

<p>That was a lot, and this is a good stopping point. I’ll resume this topic in a subsequent post.</p>

<p>To recap, we established a project directory. Created a .NET Solution and Project. Created a Rust library. We 
setup our Rust library to export a clean (<code class="language-plaintext highlighter-rouge">#[no_mangle]</code>) symbol for our <code class="language-plaintext highlighter-rouge">print_hello_world</code> function. We setup
our C# project to dynamically (at runtime) import the <code class="language-plaintext highlighter-rouge">print_hello_world</code> symbol into its code space. We called the 
<code class="language-plaintext highlighter-rouge">print_hello_world</code> method from C# to print out <code class="language-plaintext highlighter-rouge">RS: Hello, World!</code>. Then we setup our MSBuild system to build our
Rust library whenever we build the C# project and copy the Rust library into the C# project output directory so 
that the C# program is able to find the library at runtime.</p>

  </div><a class="u-url" href="/2024/08/18/calling-rust-from-c.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ramblings of a Software Engineer</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ramblings of a Software Engineer</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/dongrote"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">dongrote</span></a></li><li><a href="https://www.twitter.com/itsdongrote"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">itsdongrote</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Don is a Senior Software Engineer who decided it was time to begin chronicling his experiences.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
